# len() - длина 
# переменная.append()- добавляет что то в переменную 
# переменная.pop(8) - присваивает значение числа по тому на каком месте оно стоит и удаляет его из списка
# abs = wartość bezwzgledna (модуль)
# .upper() = сделать букву большой
# .tytle = первая буква большая остальные
# range(x,y, z) = создает список от первого числа до второго , третие число это шаг
# [] - список
# {} = словарь
# HOT KEYS
# CTRL + X - копируем и нахуй вырезаем текст
# CTRL + F2 - выделяем одинаковую строку и изменяем все такие же сразу
# Выделение с табом (табулируется сразу все)
# CTRL + SLASHHHHHHHHHHH (коментирование)


# import asyncio
# import time


# async def fun1(x):
#     print(x2)
#     await asyncio.sleep(3)
#     print('fun1 завершена')


# async def fun2(x):
#     print(x0.5)
#     time.sleep(3)
#     print('fun2 завершена')


# async def main():
#     task1 = asyncio.create_task(fun1(4))
#     task2 = asyncio.create_task(fun2(4))

#     await task1
#     await task2


# print(time.strftime('%X'))

# asyncio.run(main())

# print(time.strftime('%X'))
# Методы и функции по работе со списками
# Для управления элементами списки имеют целый ряд методов. Некоторые из них:

# append(item): добавляет элемент item в конец списка

# insert(index, item): добавляет элемент item в список по индексу index

# extend(items): добавляет набор элементов items в конец списка

# remove(item): удаляет элемент item. Удаляется только первое вхождение элемента. Если элемент не найден, генерирует исключение ValueError

# clear(): удаление всех элементов из списка

# index(item): возвращает индекс элемента item. Если элемент не найден, генерирует исключение ValueError

# pop([index]): удаляет и возвращает элемент по индексу index. Если индекс не передан, то просто удаляет последний элемент.

# count(item): возвращает количество вхождений элемента item в список

# sort([key]): сортирует элементы. По умолчанию сортирует по возрастанию. Но с помощью параметра key мы можем передать функцию сортировки.

# reverse(): расставляет все элементы в списке в обратном порядке

# copy(): копирует список

# Кроме того, Python предоставляет ряд встроенных функций для работы со списками:

# len(list): возвращает длину списка

# sorted(list, [key]): возвращает отсортированный список

# min(list): возвращает наименьший элемент списка

# max(list): возвращает наибольший элемент списка

# МНОЖЕСТВА ----------------------------------------------------------------
# add() - добавляет один элемент в множество 
# remove() - удаление одного элемента
# | - логическое сложнение 
# copy() - копировать содержимое множества в переменную 
# intersection() - позволяет получить элемент который повторяется одновременно в двух множествах 
# вместо интерсекции можно использовать логическое умножение 


# Также для удаления можно использовать метод discard(), который не будет генерировать исключения при отсутствии элемента:

# users = {"Tom", "Bob", "Alice"}
 
# users.discard("Tim")    # элемент "Tim" отсутствует, и метод ничего не делает
# print(users)    #  {"Tom", "Bob", "Alice"}
 
# users.discard("Tom")    # элемент "Tom" есть, и метод удаляет элемент
# print(users)    #  {"Bob", "Alice"}

# Метод union() объединяет два множества и возвращает новое множество:

# 1
# 2
# 3
# 4
# 5
# users = {"Tom", "Bob", "Alice"}
# users2 = {"Sam", "Kate", "Bob"}
 
# users3 = users.union(users2)

# print(users3)   # {"Bob", "Alice", "Sam", "Kate", "Tom"}

# Вместо метода union() мы могли бы использовать операцию логического сложения - |:

# users = {"Tom", "Bob", "Alice"}
# users2 = {"Sam", "Kate", "Bob"}
# add
 
# print(users | users2)   # {"Bob", "Alice", "Sam", "Kate", "Tom"}
# intersection_update() заменяет пересеченными элементами первое множество:
# пример:
# users = {"Tom", "Bob", "Alice"}
# users2 = {"Sam", "Kate", "Bob"}
# users.intersection_update(users2)
# print(users)   # {"Bob"}
# .difference  -  возвращает уникальные элементы первого множества, которых нет во втором множестве
# users = {"Tom", "Bob", "Alice"}
# users2 = {"Sam", "Kate", "Bob"}
 
# users3 = users.difference(users2)
# print(users3)           # {"Tom", "Alice"}
# print(users - users2)   # {"Tom", "Alice"}

# symetric_difference - возвращает уникальные элементы, которые есть в первом и во втором множестве и возвращает их в третье множество 
# s = {"Tom", "Bob", "Alice"}
# users2 = {"Sam", "Kate", "Bob"}
 
# users3 = users.symmetric_difference(users2)
# print(users3)   # {"Tom", "Alice", "Sam", "Kate"}
 
# users4 = users ^ users2
# print(users4)   # {"Tom", "Alice", "Sam", "Kate"}

# issubset - позволяет выяснить, является ли текущее множество подмножеством (то есть частью) другого множества:  возвращает False

# issuperset - наоборот, возвращает True, если текущее множество является надмножеством (то есть содержит) для другого множества: True 
# 
# Тип frozen set является видом множеств, которое не может быть изменено. Для его создания используется функция frozenset:
# users = frozenset({"Tom", "Bob", "Alice"})

# В такое множество мы не можем добавить новые элементы, как и удалить из него уже имеющиеся. Собственно поэтому frozen set поддерживает ограниченный набор операций:
# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
# len(s): возвращает длину множества

# x in s: возвращает True, если элемент x присутствует в множестве s

# x not in s: возвращает True, если элемент x отсутствует в множестве s

# s.issubset(t): возвращает True, если t содержит множество s

# s.issuperset(t): возвращает True, если t содержится в множестве s

# s.union(t)

# : возвращает объединение множеств s и t
# s.intersection(t): возвращает пересечение множеств s и t

# s.difference(t): возвращает разность множеств s и t

# s.copy(): возвращает копию множества s
# -----------------------------------------------------------------------------------------------------------
# # МОДУЛИ 
# Встроенный модуль math в Python предоставляет набор функций для выполнения математических, тригонометрических и логарифмических операций. Некоторые из основных функций модуля:

# pow(num, power): возведение числа num в степень power

# sqrt(num): квадратный корень числа num

# ceil(num): округление числа до ближайшего наибольшего целого

# floor(num): округление числа до ближайшего наименьшего целого

# factorial(num): факториал числа

# degrees(rad): перевод из радиан в градусы

# radians(grad): перевод из градусов в радианы

# cos(rad): косинус угла в радианах

# sin(rad): синус угла в радианах

# tan(rad): тангенс угла в радианах

# acos(rad): арккосинус угла в радианах

# asin(rad): арксинус угла в радианах

# atan(rad): арктангенс угла в радианах

# log(n, base): логарифм числа n по основанию base

# log10(n): десятичный логарифм числа n

# РАБОТА СО СТРОКАМИ 
# isalpha(): возвращает True, если строка состоит только из алфавитных символов

# islower(): возвращает True, если строка состоит только из символов в нижнем регистре

# isupper(): возвращает True, если все символы строки в верхнем регистре

# isdigit(): возвращает True, если все символы строки - цифры

# isnumeric(): возвращает True, если строка представляет собой число

# startswith(str): возвращает True, если строка начинается с подстроки str

# endswith(str): возвращает True, если строка заканчивается на подстроку str

# lower(): переводит строку в нижний регистр

# upper(): переводит строку в вехний регистр

# title(): начальные символы всех слов в строке переводятся в верхний регистр

# capitalize(): переводит в верхний регистр первую букву только самого первого слова строки

# lstrip(): удаляет начальные пробелы из строки

# rstrip(): удаляет конечные пробелы из строки

# strip(): удаляет начальные и конечные пробелы из строки

# ljust(width): если длина строки меньше параметра width, то справа от строки добавляются пробелы, чтобы дополнить значение width, а сама строка выравнивается по левому краю

# rjust(width): если длина строки меньше параметра width, то слева от строки добавляются пробелы, чтобы дополнить значение width, а сама строка выравнивается по правому краю

# center(width): если длина строки меньше параметра width, то слева и справа от строки равномерно добавляются пробелы, чтобы дополнить значение width, а сама строка выравнивается по центру

# find(str[, start [, end]): возвращает индекс подстроки в строке. Если подстрока не найдена, возвращается число -1

# replace(old, new[, num]): заменяет в строке одну подстроку на другую

# split([delimeter[, num]]): разбивает строку на подстроки в зависимости от разделителя

# partition(delimeter): разбивает строку по разделителю на три подстроки и возвращает кортеж из трех элементов - подстрока до разделителя, разделитель и подстрока после разделителя

# join(strs): объединяет строки в одну строку, вставляя между ними определенный разделитель